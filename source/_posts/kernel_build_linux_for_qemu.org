#+TITLE: 用 qemu-arm 构建内核开发环境
#+DATE: <2016-06-01 三> 
#+LAYOUT: post
#+CATEGORIES: 内核
#+OPTIONS: ^:nil

  本文为原创内容，转载请注明出处，谢谢

* 准备构建环境
** 安装交叉编译器
#+begin_example
sudo apt-get install gcc-arm-linux-guneabi
#+end_example
** 安装 qemu-arm 模拟器
#+begin_example
sudo apt-get install qemu-system-arm
#+end_example
** 创建工作目录 
#+begin_example
mkdir work 

cd work
#+end_example
work 是随便起的名字,你可以起你喜欢的名字，文章下文动作假定发生在该目录
** 下载并解压 linux 源码
#+begin_example
wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.6.tar.xz

tar xvf linux-4.6.tar.xz
#+end_example
** 下载并解压 busybox 源码
#+begin_example
wget https://busybox.net/downloads/busybox-1.24.2.tar.bz2

tar xvf busybox-1.24.2.tar.bz2
#+end_example
* 编译内核
** 配置内核
#+begin_example
cd linux-4.6

make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm vexpress_defconfig
#+end_example
vexpress 是 qemu 支持模拟的一种开发板，内核针对该平台编译
** 编译内核
#+begin_example
make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm
#+end_example
编译根据机器性能会耗费几分钟到几十分钟不等，一般情况下 20 分钟内能编译完成，请耐心等待
** 拷贝镜像
#+begin_example
cd ..

cp linux-4.6/arch/arm/boot/zImage .

cp linux-4.6/arch/arm/boot/dts/vexpress-v2p-ca9.dtb .
#+end_example
zImage 为编译后的内核镜像,vexpress-v2p-ca9.dtb 为编译后的设备树描述文件
* 编译 busybox
** 配置 busybox
#+begin_example
cd busybox-1.24.2

make defconfig

make menuconfig 
进入菜单 Busybox Settings -> Build Options -> Build BusyBox as a static binary 选中并保存
#+end_example
** 编译 busybox
#+begin_example
make CROSS_COMPILE=arm-linux-gnueabi- 
#+end_example
** 安装 busybox
#+begin_example
sudo make CROSS_COMPILE=arm-linux-gnueabi- install 
#+end_example
这里用 sudo 安装的目的是为了使安装的文件属主为 root，busybox 会自动将程序安装在当前目录的_install 目录下
* 制作根文件系统
** 生成并格式化镜像
请确保在 work 根目录，后边不在赘述
#+begin_example
dd if=/dev/zero of=rootfs.img bs=1M count=30

mkfs.ext4 rootfs.img
#+end_example
用 dd 命令生成一个 30M 的文件，并格式化成 ext4 格式，有些系统 mkfs.ext4 命令可能在/sbin/目录，如果说找不到 mkfs.ext4 命令时请用/sbin/mkfs.ext4 引用全路径
** 创建临时目录并挂载镜像
#+begin_example
mkdir tmp

sudo mount -o loop rootfs.img tmp
#+end_example
将创建的镜像文件挂载到 tmp 目录，这样就能往里面存取文件
** 复制 busybox 文件
#+begin_example
sudo cp -ar busybox-1.24.2/_install/* tmp
#+end_example
** 在根文件系统内创建必要的目录
#+begin_example
cd tmp

sudo mkdir -p lib proc sys dev etc/init.d

cd ..
#+end_example
** 复制系统 c 运行时库 
#+begin_example
sudo cp -ar /usr/arm-linux-gnueabi/lib/* tmp/lib
#+end_example
** 创建系统初始化脚本
#+begin_example
sudo vi tmp/etc/init.d/rcS

输入以下内容并保存
#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev
mdev -s
#+end_example
这里要解释一下，tmp 目录下的 linuxrc 为内核默认执行的第一个用户程序，而这个程序又会默认去执行 etc/init.d/rcS，这个初始化脚本可以用来做系统初始化时要做的任何事情，
我们这里仅仅挂载里几个系统关键的虚拟文件系统并启动 mdev 程序，你可以根据需要添加其他任务
** 卸载镜像（可略过）
#+begin_example
sudo umount tmp
#+end_example
* 用模拟器启动系统
** 写启动脚本
#+begin_example
vi run.sh

输入一下内容并保存
#!/bin/sh
qemu-system-arm -M vexpress-a9 -m 512M -kernel zImage -dtb vexpress-v2p-ca9.dtb -sd rootfs.img -nographic -append "root=/dev/mmcblk0 console=ttyAMA0"

添加执行权限
chmod +x run.sh
#+end_example
之所以制作脚本启动，是由于输入的参数太多了，不想每次输入
** 启动系统
#+begin_example
./run.sh
#+end_example
这样就可以用 qemu 虚拟机来启动自己编译的内核了，之后如果需要修改内核或者驱动，可以重新编译内核，或者将程序编译成模块放到根文件系统内即可，祝愉快！

